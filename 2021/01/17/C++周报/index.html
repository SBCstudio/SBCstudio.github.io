<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++周报 | SBCstudio</title><meta name="author" content="SBC"><meta name="copyright" content="SBC"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="C++周报 一．面向对象的概念 面向对象方法是分析问题和解决问题的新方法，其基本出发点就是尽可能按照人类认识世界的方法和思维方式来分析和解决问题。面向对象以对象为最基本的元素，是一种由对象、类、封装、继承和多态等概念来构造系统的软件开发方法。 1．对象（Object） 对象是现实世界中客观存在的某种事物，可以将人们感兴趣或要加以研究的事、物和概念等都称为对象。对象既能表示结构化的数据，也能表示抽象">
<meta property="og:type" content="article">
<meta property="og:title" content="C++周报">
<meta property="og:url" content="http://example.com/2021/01/17/C++%E5%91%A8%E6%8A%A5/index.html">
<meta property="og:site_name" content="SBCstudio">
<meta property="og:description" content="C++周报 一．面向对象的概念 面向对象方法是分析问题和解决问题的新方法，其基本出发点就是尽可能按照人类认识世界的方法和思维方式来分析和解决问题。面向对象以对象为最基本的元素，是一种由对象、类、封装、继承和多态等概念来构造系统的软件开发方法。 1．对象（Object） 对象是现实世界中客观存在的某种事物，可以将人们感兴趣或要加以研究的事、物和概念等都称为对象。对象既能表示结构化的数据，也能表示抽象">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2021-01-17T11:57:15.000Z">
<meta property="article:modified_time" content="2021-01-28T07:46:30.783Z">
<meta property="article:author" content="SBC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/01/17/C++%E5%91%A8%E6%8A%A5/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2021-01-28 15:46:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/SBC.jpg'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">SBCstudio</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++周报</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-17T11:57:15.000Z" title="发表于 2021-01-17 19:57:15">2021-01-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-01-28T07:46:30.783Z" title="更新于 2021-01-28 15:46:30">2021-01-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>C++周报</strong></p>
<p><strong>一．面向对象的概念</strong></p>
<p>面向对象方法是分析问题和解决问题的新方法，其基本出发点就是尽可能按照人类认识世界的方法和思维方式来分析和解决问题。面向对象以对象为最基本的元素，是一种由对象、类、封装、继承和多态等概念来构造系统的软件开发方法。</p>
<p>1．对象（Object）</p>
<p>对象是现实世界中客观存在的某种事物，可以将人们感兴趣或要加以研究的事、物和概念等都称为对象。对象既能表示结构化的数据，也能表示抽象的事件、规则以及复杂的工程实体等。</p>
<p>在面向对象的系统中，对象是一个将数据属性和操作行为封装起来的实体。数据描述了对象的状态，是对象的静态特性；操作用来描述对象的动态特性，可以操纵数据，改变对象的状态。</p>
<p>对象之间传递信息是通过消息实现的，当一个对象对另一个对象发出的消息进行响应时，其操作才得以实现。</p>
<p>2．类（Class）</p>
<p>类是人们对客观事物的高度抽象。抽象是指抓住事物的本质特性，找出事物之间的共性，并将具有共同特性的事物划分为一类，得到一个抽象的概念。例如，人、汽车、房屋、水果等都是类的例子。</p>
<p>类是一种类型，是具有相同属性和操作的一组对象的集合。类的作用是定义对象，类给出了属于该类的全部对象的抽象定义，而对象则是类的具体化，是符合这种定义的一个类的实例。类还可以有子类和父类，子类通过对父类的继承，形成层次结构。</p>
<p>把一组对象的共同特性加以抽象并存储在一个类中的能力，是面向对象技术中最重要的一点；是否建立了一个丰富的类库，则是衡量一个面向对象程序设计语言成熟与否的重要标志。</p>
<p>3．封装（Encapsulation）</p>
<p>封装是面向对象方法的重要特征之一，是指将对象的属性和行为（数据和操作）包裹起来形成一个封装体。该封装体内包含对象的属性和对象的行为，对象的属性由若干个数据组成，而对象的行为则由若干操作组成，这些操作是通过函数来实现的，也称之为方法。</p>
<p>封装体具有独立性和隐藏性。独立性是指封装体内所包含的属性和行为构成了一个不可分割的独立单位。隐藏性是指封装体内的某些成员（数据或者方法）在封装体外是不可见的，既不能被访问，也不能被改变，这部分成员被隐藏了，具有安全性。一般地，封装体和外界的联系是通过接口来进行的。</p>
<p>4．继承（Inheritance）</p>
<p>继承是面向对象方法的另一重要特征，是提高重用性的重要措施。继承提供了创建新类的一种方法，表现了特殊类与一般类的关系。特殊类具有一般类的全部属性和行为，并且还具有自己特殊的属性和行为，这就是特殊类对一般类的继承。通常将一般类称为基类（父类），而将特殊类称为派生类（子类）。</p>
<p>使用继承可以使人们对事物的描述变得简单。例如已经描述了动物这个类的属性和行为，由于哺乳动物是动物的一种，它除了具有动物这个类的所有属性和行为外，还具有自己的特殊的属性和行为，这样在描述哺乳动物时就只需要在继承动物类的基础上再加入哺乳动物所特有的属性和行为就行了。因此哺乳动物是特殊类，是子类，而动物是一般类，是父类。</p>
<p>继承的本质特征就是行为共享，通过行为共享，可以减少冗余性，很好地解决软件重用性的问题。</p>
<p>5．消息（Message）</p>
<p>对象与对象之间是通过消息进行通讯的，这种通讯机制叫做消息传递。消息传递是通过函数调用来实现的。当一个消息发送给某个对象时，该消息中包含要求接收对象去执行某些活动的信息，接收到消息的对象经过解释，然后予以响应。发送消息的对象不需要知道接收消息的对象是如何对请求予以响应的。</p>
<p>6．多态（Polymorphism）</p>
<p>多态性指的是一种行为对应着多种不同的实现。在同一个类中，同一种行为可以对应不同的实现，如：函数重载和运算符重载。同一种行为在一般类和它的各个特殊类中可以具有不同的实现，即不同的对象在收到同一消息时可产生完全不同的结果。多态性的表现就是允许不同类的对象对同一消息做出响应，即同一消息可以调用不同的方法，而实现的细节则由接收对象自行决定。</p>
<p>多态的实现受到继承性的支持，利用类的继承的层次关系，把具有通用功能的消息存放在高层次，而这一功能行为的不同实现放在较低层次，在这些低层次上生成的对象能够给通用消息以不同的响应。多态性是面向对象方法的又一特征，很好地解决了应用程序中函数同名问题。</p>
<p><strong>二．C++中的特性</strong></p>
<p>1.输出HelloWorld的简单的C++程序</p>
<p>#include <iostream>           </iostream></p>
<p>using namespace std;                 </p>
<p>int main()               </p>
<p>{</p>
<p>​    cout &lt;&lt;”Hello World”&lt;&lt;endl; </p>
<p>​    system(“pause”);</p>
<p>return 0;</p>
<p>}</p>
<p>“#include <iostream>”是一个预处理命令。文件iostream的内容是提供输入或输出时所需要的一些信息。因为这类文件都放在程序开头，所以称为“头文件”。</iostream></p>
<p>在C语言中所有头文件都带后缀.h（如stdio.h），而按C++标准要求，由系统提供的头文件不带后缀.h（iostream），用户自己编制的头文件可以有后缀.h。在C++程序中也可以使用C语言编译系统提供的带后缀.h的头文件，如“#include &lt;math.h&gt;”。</p>
<p>“using namespace std;”的意思是“使用命名空间std”。 C++标准库中类和函数是在命名空间中声明的，因此程序中如果需要使用C++标准库中的有关内容，就需要用“using namespace std;”语句声明，表示要用到命名空间std中的内容。如果程序中有输入或输出，必须使用“#include <iostream>”命令提供信息，同时要用“using namespace std;”语句使程序能够使用这些信息，否则程序编译时将出错。本书中所有程序示例的开头都包含这两行语句。</iostream></p>
<p>在C++程序中，一般用cout进行输出。cout是C++系统定义的对象名，称为输出流对象，通常和“&lt;&lt;”一起实现输出功能。和cout对应的还有cin对象名，称为输入流对象，通常和“&gt;&gt;”一起实现从键盘输入信息的功能。C++中也可以使用C语言中的scanf和printf函数进行输入和输出。</p>
<p>在C++中一般在main函数中的return之前添加system(“pause”);这样就可以看清楚输出的结果，pause会输出”press any key to continue. . .”。</p>
<p>2.C++程序的组成</p>
<p>(1)预处理命令</p>
<p>C++程序开始经常出现的含有以“#”开头的命令，它们是预处理命令。C++提供了三类预处理命令：文件包含命令、宏定义命令和条件编译命令。本书很少涉及后两种预处理命令，因此不做详细介绍，需要时请参考相关书籍。</p>
<p>示例中出现的“#include <iostream>”是文件包含命令，是一种常用的预处理命令，其中include 是关键字，“&lt;&gt;”中是被包含的文件名。由于iostream头文件中包含有预定义的提取符“&gt;&gt;”和插入符“&lt;&lt;”等内容，在程序编写时，若要使用这些运算符就必须包含iostream头文件。如果在源程序中使用了系统提供的一些函数，例如：数学函数（正弦函数sin()、求平方根函数sqrt()和求整数绝对值函数abs()等），则应该在预处理命令中包含math头文件，即源程序开始部分加上“#include <math>”。具体头文件名请参考C++常用库函数。</math></iostream></p>
<p>(2)输入/输出</p>
<p>C++程序中的输入/输出操作是通过输入/输出流对象cin和cout来实现的，在实现的过程中经常会用到运算符和表达式等。</p>
<p>(3)函数</p>
<p>一个C++程序可以由若干个文件组成，每个文件又可以包含多个函数，函数是构成C++程序的基本单位。C++程序中至少要包含一个主函数main()，并且只能有一个main()函数。C++程序的执行总是从main()函数开始，而其余函数的执行则只能通过主函数来调用或被主函数调用的其他函数来调用执行。函数的调用既可以嵌套，又可以递归。被调用的其他函数可以是系统提供的库函数，也可以是用户自定义的函数。如例1.3的C++程序就是由主函数main()和用户自定义函数Max()组成的。</p>
<p>(4)语句</p>
<p>按照结构化程序设计的观点，程序是由函数组成的，而函数又是一组语句序列，所以语句是构成C++程序的基本单元。空函数没有语句。C++中的每条语句必须以分号结束。</p>
<p>C++语句按功能可分为三大类：</p>
<p>定义和声明语句，对程序中出现的标识符进行定义和声明的语句。</p>
<p>操作运算语句，用于描述计算机执行的操作运算的语句，主要有赋值语句、函数调用语句、复合语句和空语句。</p>
<p>流程控制语句，用于控制上述操作运算语句的执行顺序的语句，有条件语句、循环语句和转向语句等。</p>
<p> (5)变量</p>
<p>多数程序都需要使用变量，变量的类型有很多种，如int型、float型、double型和char型等。</p>
<p>对象cout和cin，属于“类”类型。广义地讲，对象包含了变量，即将变量也称为一种对象，狭义地讲，将对象看作是类的实例，对象是指某个类的对象。</p>
<p>(6)其他</p>
<p>一个C++程序中，除了上述5个部分以外，还有其他组成部分。如符号常量和注释信息也是程序的一部分。</p>
<p>C++中尽量把常量定义为符号常量，如用预处理命令中的宏定义命令：</p>
<p>#define PI 3.14159</p>
<p>其中define是关键字，表示定义一个符号常量PI，它所代表的常量值是3.14159。</p>
<p>另一种方法是使用常量关键字const，例如：</p>
<p>const double PI=3.14159;</p>
<p>这也是将一个符号常量PI定义为3.14159。</p>
<p>使用符号常量会带来很多好处：方便修改、便于移植、增加可读性等。</p>
<p>对较复杂的或大型的软件少不了注释信息，在C++程序的任何位置都可以插入注释信息，这些注释信息增加了程序的可读性。</p>
<p>3.字符串类变量</p>
<p>添加头文件#include<string>，string 变量名 = “字符串值”;</string></p>
<p>4.布尔类型变量</p>
<p>bool 变量名 = true/false</p>
<p>5.随机数</p>
<p>添加头文件#include<ctime>,</ctime></p>
<p>先执行srand((unsigned int)time(NULL));</p>
<p>通过rand()产生一个[0,1)的随机数</p>
<p><strong>三．基本数据类型</strong></p>
<p>C++的基本数据类型有4种：字符型、整型、浮点型和布尔型。</p>
<p>字符型只占用一个字节，用来存放一个ASCII字符或一个8位的二进制数，其说明符为char；整型用来存放一个整数，其说明符为int，其所占的字节数随不同型号的计算机而异，可以占用2个或4个字节，在32位的计算机上占4个字节；浮点型，又称实型，用来存放实数。布尔型是C++新增的一个数据类型，它占一个字节，只能取两个值：false和true。C语言不支持布尔类型，而是把整型值0作为逻辑值false，任何非零值作为逻辑true。                                                            </p>
<p>通过在这些基本数据类型前面加上以下几个修饰词可组合成多种类型。这几个修饰词的含义如下：</p>
<p>signed    有符号型</p>
<p>unsigned   无符号型</p>
<p>long      长型</p>
<p>short      短型</p>
<p>这4种修饰词都适用于整型和字符型，而long同时还适用于双精度浮点型。</p>
<p>例如：unsigned char为无符号字符型；long int为长整型；unsigned short int为无符号短整型；long double为长双精度型。</p>
<table>
<thead>
<tr>
<th>类型名</th>
<th>字宽</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>char</td>
<td>1</td>
<td>-128~127</td>
</tr>
<tr>
<td>signed char</td>
<td>1</td>
<td>-128~127</td>
</tr>
<tr>
<td>unsigned char</td>
<td>1</td>
<td>0~255</td>
</tr>
<tr>
<td>short [int]</td>
<td>2</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>signed short [int]</td>
<td>2</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>unsigned short [int]</td>
<td>2</td>
<td>0-65535</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>signed [int]</td>
<td>4</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>unsigned [int]</td>
<td>4</td>
<td>0-4294967295</td>
</tr>
<tr>
<td>long [int]</td>
<td>4</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>signed long [int]</td>
<td>4</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>unsigned long [int]</td>
<td>4</td>
<td>0-4294967295</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>约6位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>约12位有效数字</td>
</tr>
<tr>
<td>long double</td>
<td>16</td>
<td>约15位有效数字</td>
</tr>
</tbody></table>
<p>(1)用这4个修饰词来修饰int时，关键字int可以省略，例如long 等同于long int，unsigned short等同于unsigned short int。</p>
<p>(2)在C++中，无修饰词的int和char，编译程序认为是有符号的，即等同于前面加了修饰signed。</p>
<p>(3)单精度类型float，双精度类型double和长双精度类型long double统称为浮点类型。</p>
<p>(4)表2-1中的各种数据类型的字宽是以字节为单位的。</p>
<p><strong>四．C++系统关键字及含义描述</strong></p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>含义描述</th>
</tr>
</thead>
<tbody><tr>
<td>break</td>
<td>跳出循环体，结束循环</td>
</tr>
<tr>
<td>case</td>
<td>分支语句中的分支</td>
</tr>
<tr>
<td>char</td>
<td>字符型数据</td>
</tr>
<tr>
<td>class</td>
<td>定义类的关键字</td>
</tr>
<tr>
<td>const</td>
<td>常量符号</td>
</tr>
<tr>
<td>continue</td>
<td>跳出本次循环，进行下一次</td>
</tr>
<tr>
<td>default</td>
<td>分支语句中的默认分支</td>
</tr>
<tr>
<td>delete</td>
<td>释放指针指向的内存块</td>
</tr>
<tr>
<td>do</td>
<td>do型循环</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点型数据</td>
</tr>
<tr>
<td>else</td>
<td>判断语句中的否定分支</td>
</tr>
<tr>
<td>enum</td>
<td>定义枚举型数据</td>
</tr>
<tr>
<td>extern</td>
<td>声明外部变量</td>
</tr>
<tr>
<td>float</td>
<td>单精度浮点型数据</td>
</tr>
<tr>
<td>for</td>
<td>for型循环</td>
</tr>
<tr>
<td>friend</td>
<td>友元类</td>
</tr>
<tr>
<td>goto</td>
<td>跳转语句</td>
</tr>
<tr>
<td>if</td>
<td>条件判断语句</td>
</tr>
<tr>
<td>inline</td>
<td>声明为内联函数</td>
</tr>
<tr>
<td>int</td>
<td>整型数据</td>
</tr>
<tr>
<td>long</td>
<td>长整型数据</td>
</tr>
<tr>
<td>new</td>
<td>申请内存块</td>
</tr>
<tr>
<td>operator</td>
<td>定义运算符重载</td>
</tr>
<tr>
<td>private</td>
<td>私有成员；私有继承</td>
</tr>
<tr>
<td>protected</td>
<td>保护成员；保护继承</td>
</tr>
<tr>
<td>public</td>
<td>公有成员；公有继承</td>
</tr>
<tr>
<td>return</td>
<td>从函数中返回</td>
</tr>
<tr>
<td>short</td>
<td>短整型数据</td>
</tr>
<tr>
<td>signed</td>
<td>有符号型数据</td>
</tr>
<tr>
<td>sizeof</td>
<td>取数据类型长度运算符</td>
</tr>
<tr>
<td>static</td>
<td>静态数据</td>
</tr>
<tr>
<td>struct</td>
<td>定义结构体类型数据</td>
</tr>
<tr>
<td>switch</td>
<td>分支语句</td>
</tr>
<tr>
<td>template</td>
<td>声明模板</td>
</tr>
<tr>
<td>this</td>
<td>本类指针</td>
</tr>
<tr>
<td>typedef</td>
<td>重定义数据类型</td>
</tr>
<tr>
<td>union</td>
<td>定义联合体型数据</td>
</tr>
<tr>
<td>virtual</td>
<td>虚继承；虚函数</td>
</tr>
<tr>
<td>void</td>
<td>定义函数不返回数值</td>
</tr>
<tr>
<td>while</td>
<td>while型循环</td>
</tr>
</tbody></table>
<p><strong>五．C++中常用转义字符及其功能描述</strong></p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>‘\a’</td>
<td>响铃符</td>
<td>用于输出</td>
</tr>
<tr>
<td>‘\b’</td>
<td>退格符</td>
<td>用于回退一个字符</td>
</tr>
<tr>
<td>‘\f’</td>
<td>换页符</td>
<td>用于输出</td>
</tr>
<tr>
<td>‘\r’</td>
<td>回车符</td>
<td>用于输出</td>
</tr>
<tr>
<td>‘\t’</td>
<td>水平制表符</td>
<td>用于制表</td>
</tr>
<tr>
<td>‘\’</td>
<td>反斜杠符</td>
<td>用于输出或文件的路径名中</td>
</tr>
<tr>
<td>‘\’’</td>
<td>单引号</td>
<td>用于输出单引号</td>
</tr>
<tr>
<td>‘\”’</td>
<td>双引号</td>
<td>用于输出双引号</td>
</tr>
<tr>
<td>‘\0’</td>
<td>空字符</td>
<td>用于结束标志</td>
</tr>
</tbody></table>
<p><strong>六．C++中的10种复合赋值运算符</strong></p>
<table>
<thead>
<tr>
<th>符号表示</th>
<th>含义描述</th>
<th>符号表示</th>
<th>含义描述</th>
</tr>
</thead>
<tbody><tr>
<td>+=</td>
<td>加赋值</td>
<td>-=</td>
<td>减赋值</td>
</tr>
<tr>
<td>*=</td>
<td>乘赋值</td>
<td>/=</td>
<td>除赋值</td>
</tr>
<tr>
<td>%=</td>
<td>求余赋值</td>
<td>&lt;&lt;=</td>
<td>左移位赋值</td>
</tr>
<tr>
<td>&gt;&gt;=</td>
<td>右移位赋值</td>
<td>&amp;=</td>
<td>按位与赋值</td>
</tr>
<tr>
<td>|=</td>
<td>按位或赋值</td>
<td>^=</td>
<td>按位异或赋值</td>
</tr>
</tbody></table>
<p><strong>七．C++中的6种位操作运算符</strong></p>
<table>
<thead>
<tr>
<th>符号表示</th>
<th>含义描述</th>
</tr>
</thead>
<tbody><tr>
<td>~</td>
<td>按位求反</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
</tr>
</tbody></table>
<p> <strong>八．程序流程结构</strong></p>
<p>(1)if语句、switch语句、while语句、do while语句、for语句、break语句、continue语句同C语言。</p>
<p>(2)goto语句：</p>
<p>可以无条件跳转语句，如果标记的名称存在，执行到goto语句时，会跳转到标记的位置。</p>
<p>xxxxxxxx;</p>
<p>goto FLAG;</p>
<p>xxxxxxxx;</p>
<p>xxxxxxxx;</p>
<p>FLAG;</p>
<p>xxxxxxxx;</p>
<p><strong>九．数组</strong></p>
<p>定义方式同C语言，</p>
<p>一维数组：int arr[5]={1,2,3,4,5}</p>
<p>二维数组：int arr[2] [3]={1,2,3,4,5,6}</p>
<p><strong>十．函数</strong></p>
<p>(1)函数的定义</p>
<p>函数的定义由函数头和函数体组成。在C++中定义一个函数的格式如下：</p>
<p>&lt;函数类型&gt;  &lt;函数名&gt; (&lt;参数表&gt;)     //函数头</p>
<p>{</p>
<p>  &lt;若干条语句&gt;             //函数体</p>
<p>}</p>
<p>&lt;函数类型&gt;是指函数执行完成之后，返回给调用它的函数的信息的类型，函数可以有返回值也可以没有返回值，当没有返回值时函数的类型为void类型。函数返回值的类型可以是各种数据类型。关于函数类型将在后面进行详细的介绍。</p>
<p>&lt;函数名&gt;也是一种标识符，它符合标识符的定义规则，即由字母、数字和下划线组成，必须以字母或下划线开头。一般根据函数具体的功能来定义函数名，起到“见名知意”的作用。当程序启动时，系统自动调用主函数main()，然后再由主函数调用其他函数，或者由其他函数再调用其他的函数。</p>
<p>&lt;参数表&gt;中参数的个数可以是0个、1个或多个，但是当无任何参数时，函数后的小括号也不可以省略。参数表是外界向函数内部传递信息的通道。</p>
<p>函数体是由若干条语句组成的一个独立完成某个功能的语句块，每条语句以分号“；”结尾。例如，在ComputeArea()函数中完成面积的计算，main()函数负责长方形的长、宽信息的输入与面积的输出。对于使用者来说，只需知道函数完成的功能和输入输出的信息是什么即可，而不需要了解具体实现的方法和步骤，例如面积是怎么求得的不需要知道，因此可以把函数看作一个“黑匣子”。但是对于编程者来说，则需要全方位理解，不但需要知道如何根据长方形的长和宽计算出面积，而且还需要知道需要通过什么样的语句完成这样的功能，因此程序员就像是一个机械师，知道如何制作“黑匣子”。函数体中可以不含有任何语句，这时将该函数称为空函数。</p>
<p>每个函数都由函数类型、函数名、参数表和函数体这4部分组成，缺一不可，函数不返回任何信息时，函数类型为void型；函数必须有一个函数名，而参数表不含有参数时，一对小括号也不可省略，函数体不需要任何语句时花括号也同样不可省。</p>
<p>(2)函数的声明</p>
<p>在C++中要求函数被调用之前，必须进行函数的定义或声明。但是经验表明，人们在阅读程序时通常是从main()函数开始，习惯于将main()函数放在最前面。因此在main()函数中调用到的函数需要提前进行说明，这就是函数声明。</p>
<p>函数声明的格式与函数定义时的函数头基本相同，函数声明本身是一条语句，因此在函数头后加“；”，其格式如下：</p>
<p>&lt;函数类型&gt; &lt;函数名&gt; (&lt;参数表&gt;)；</p>
<p>请注意在函数声明语句后有“；”，而在函数定义时，函数头的后面没有“；”。</p>
<p>当一个程序含有多个函数时，如果不进行函数声明，程序员就需要仔细考虑函数之间的调用关系，然后再决定函数定义的先后顺序。如果进行函数声明的话，程序员只需要在main()主函数前对所有函数进行声明，如上例可以在主函数前先将Fun1()、Fun2()、Fun3()和Fun4()进行声明，这样就可以将除main()主函数之外的其他所有函数定义放在main()之后，而且不需要考虑它们之间的顺序。这不但减轻了编程者的工作量，避免了函数调用之间关系的错误，同时也使得读者对程序一目了然，程序的可读性强，因此编程者应该养成一个良好的函数声明的习惯。</p>
<p>(3)函数的类型</p>
<p>函数的参数是外界向函数内部输入信息的通道，而函数的类型则说明了函数执行完成后，向外界输出的信息的类型。输出的信息可以是任何数据类型，如char、int、float、double等基本数据类型，也可以是自定义的结构体类型等构造数据类型，还可以是指针或引用，另外也可以是第5章中要讲到的类。</p>
<p>一般情况下，定义函数时，函数的类型与函数体中return语句返回的数据的类型相一致，当return语句返回int类型数据时，则该函数的类型定义为int；当return 返回char类型数据时，则该函数的类型定义为char；当return 返回的是一个结构体时，则该函数的类型定义为该结构体的类型。每个函数根据功能的需求可以有一个返回值，也可以没有返回值。当函数体中有return语句，且该语句后有返回数值或表达式时，该函数的类型就定义为返回值的类型；当无返回值时，函数的类型则为void型。</p>
<p>函数的类型是在函数声明和定义时约定的，当程序运行时，如果return语句返回的数值类型与函数类型不符，则在返回时，先做隐含的类型转换，然后再返回，这种转换有时会造成计算精度的降低。</p>
<p>(4)函数的参数</p>
<p>函数的参数是函数完成功能所需要的输入信息，也就是说参数可以控制函数的行为。</p>
<p>函数可以没有参数也可以有多个参数，这需根据函数的功能和执行方式来具体决定。当函数不含有任何参数的时候，函数名后的小括号也不能省略，如果函数有多个参数时需要将参数的类型和参数名写到参数表中，参数之间用逗号分隔。</p>
<p>​    函数的参数可以是任何类型数据，它们可以是基本数据类型如字符型、实型等，也可以是构造数据类型，如对象、数组、结构体等，还可以是指针和引用类型。不同数据类型的参数传递输入信息的方法和作用各不相同，在讲解函数调用的时候将详细介绍不同数据类型传递数值的方式和作用。</p>
<p>​    有时需要用相同的实参反复调用同一函数，为了避免反复传递相同实参的信息， C++中允许给函数定义默认的参数值。</p>
<p>默认参数在使用时需要注意以下两点：</p>
<p>1.当程序中既有函数的声明又有函数的定义时，默认参数只能在函数声明中给出，而定义中不允许设置默认参数。但是当程序中没有函数的声明时，则默认参数必须在函数定义中出现。</p>
<p>2.如果一个函数中有多个参数，则设置参数默认值时，要求从右向左逐渐设置。当调用函数时，只能将实参从左向右为形参赋值，当实参数量少于形参数量时，形参从左向右与实参匹配，剩余形参则取默认值。因此要求设置参数默认值时，需要从右向左逐渐设置。</p>
<p>(5)函数的调用</p>
<p>​    调用函数是实现函数功能的必要手段，当调用一个函数时就是暂时中断现有程序的运行，转去执行被调用函数，即程序的执行权交给了被调用函数，当被调用函数执行结束后，返回到中断处继续执行原程序，即被调用函数将程序的执行权交回给调用它的函数。</p>
<p>​    如何调用函数是C++的一个重要内容，C++提供了多种函数调用的方式，C++的函数调用要比C语言更加丰富。函数的调用是在表达式、语句或参数中直接写出函数名，根据被调用函数在源程序中出现的位置，可以把函数调用分为语句调用、表达式调用和参数调用三种情况。</p>
<p>​    语句调用是函数调用最常用的方式，被调用函数作为一个独立的语句出现在源程序中。如果函数有返回值时其语句调用格式如下：</p>
<p>&lt;变量名&gt;=&lt;函数名&gt;&lt;实参表&gt;；</p>
<p>赋值号前面的变量是用来接收函数返回值的。</p>
<p>如果函数没有返回值，则其语句调用方式更为简单，只要把被调用的函数名写出，用实参替换形参即可。即：</p>
<p>&lt;函数名&gt;&lt;实参表&gt;；</p>
<p>表达式调用是指被调用函数出现在表达式中，这种表达式也称为函数表达式。表达式调用只适用于具有返回值的函数，只需在表达式的适当位置写上函数名，然后用实参替换形参就可以了，函数的返回值作为表达式中的一个数值进行计算。</p>
<p>参数调用是指被调用函数作为一个参数出现在另一个函数调用的语句中，这种调用方式虽然形式上不同于表达式调用，但它们的调用条件却是一样的，都要求被调用函数必须具有返回值，同时它们的调用方法也是相同的。</p>
<p>前面介绍的函数的调用方式是根据被调用函数在源程序中出现的位置来划分的，而根据函数参数传递的不同方式又可将函数调用分为函数传值调用、函数传址调用和函数引用调用三种不同的函数调用方式。</p>
<p>1．函数的传值调用</p>
<p>函数传值调用是将实参的值复制一个备份，将这个备份传递给形参，因为形参只是实参的一个备份，它们各自具有单独的存储空间，因此在被调用函数内对形参进行处理，改变形参的值时，实参的值不会受到任何影响。因此传值调用多用在不需要被调用函数改变实参的值的场合。传值调用的时候，调用函数的实参用常量、变量或表达式，被调用函数的形参必须用变量，不能是指针或引用。</p>
<p>在进行程序设计时，有时不希望形参的改变影响到实参，但是有时候又需要实参能够随着形参而发生变化，这种情况就需要选用下面的两种函数调用方式：传址调用和引用调用。</p>
<p>2．函数的传址调用</p>
<p>在C++中一个变量有两个含义，一个是直接用变量名来表示变量本身的值，另一个就是变量本身的存储地址。函数的传值调用时，实参向形参传递的是变量的值，而传址调用则传递的是变量的存储地址。在C++中，变量的存储地址是用指针来表示的。函数的传址调用时实参传的是地址值，用地址常量或指针变量表示，而形参用指针变量。函数调用时系统将实参所表示的地址值赋给形参的指针变量，从而使得形参和实参的指针指向的是相同的存储地址。</p>
<p>3．函数的引用调用</p>
<p>在C语言中没有引用这种数据类型，因此也就没有引用调用这种函数调用方式。C++引用数据类型不同于指针，它既不是某个变量的地址，也不是某个变量的备份，引用通常被认为是变量的别名。指针是通过地址间接访问变量，而引用则通过别名间接访问变量，所有在引用上所施加的操作，实质上就是在被引用变量上的操作。引用主要用于函数的形参和函数的返回值。</p>
<p>使用函数的引用调用时，函数的实参用变量名，被调用函数的形参用引用，函数调用时是将实参的变量名赋值给了对应形参的引用，也就是形参是实参的别名，所以在被调用函数中对形参的处理也就是对实参的操作。</p>
<p>(6)函数的分文件编写</p>
<p>1.创建.h后缀名的头文件</p>
<p>2.创建.cpp后缀名的源文件</p>
<p>3.在头文件中写函数的声明</p>
<p>4在源文件中写函数的定义</p>
<p>5.在源文件中包含创建的头文件#include”创建的头文件.h”</p>
<p>6.引用时包含头文件#include”创建的头文件.h”</p>
<p><strong>十一．指针</strong></p>
<p>(1)  指针变量的定义：</p>
<p>指针变量的定义格式为：</p>
<p>&lt;指针类型&gt; *&lt;指针名&gt;；</p>
<p>符号“*”是说明符或修饰符，用来表示它后面的标识符是指针变量名。</p>
<p>例如：</p>
<p>int *p；</p>
<p>p是指针变量的名字，int表示该指针p的类型是整型指针，也就是指针p所指向的存储空间只能存放整型数，称之为int *型指针。</p>
<p>指针除了可以指向变量之外，还可以指向函数。例如：</p>
<p>int( * pf ) ( );</p>
<p>pf是一个指向函数的指针，该函数的返回值为int型数值。</p>
<p>指针变量的定义语句由数据类型后跟“<em>”，再跟指针变量名组成。“</em>”向左靠向数据类型，向右靠向指针名或者居中所表示的意思都是相同的。例如：</p>
<p>int *p；</p>
<p>int* p；</p>
<p>int * p；</p>
<p>上面的三个语句表示同一个含义，即定义一个名为p的int *型指针。</p>
<p>指针是一种变量，因此在所有能够定义变量的地方均可声明指针变量。一个“*”只能定义一个指针，如语句int <em>p1,p2;表示定义了一个名为p1的int *型指针和一个名为p2的整型变量，而不是两个int *型指针。要想定义多个指针需要在每个指针名前加“</em>”，如：</p>
<p>int <em>p1，</em>p2； </p>
<p>定义了二个int *型指针变量p1和p2。</p>
<p>指针名可以使用任何合法的变量名，但是许多程序员习惯使用p开头的标识符命名指针。</p>
<p>(2)  空指针和野指针</p>
<ol>
<li><p>空指针：指针变量指向内存编号为0的空间，用于初始化指针变量，空指针指向的变量是不可以访问的。</p>
</li>
<li><p>野指针：指针变量指向非法的内存空间，尽量避免野指针.</p>
</li>
</ol>
<p>(3)  const修饰指针</p>
<ol>
<li><p>const修饰指针——常量指针:const int*p=&a;指针的指向可以修改，但指针指向的值不可以修改。</p>
</li>
<li><p>const修饰常量——指针常量:int *const p =&a;指针的指向不可以改，但指向的值可以改。</p>
</li>
<li><p>const既修饰指针，又修饰常量:const int *const p=&a;指针的指向和值都不能改。</p>
</li>
</ol>
<p><strong>十二．结构体</strong></p>
<p>(1)  结构体的定义和使用</p>
<ol>
<li>struct 变量类型{</li>
</ol>
<p>类型1 变量名1;</p>
<p>类型2 变量名2;</p>
<p>类型3 变量名3;</p>
<p>}</p>
<p>例：</p>
<p>struct student{</p>
<p>string name;</p>
<p>int age;</p>
<p>int score;</p>
<p>}</p>
<ol start="2">
<li>赋值方法：</li>
</ol>
<p>变量类型 变量名={值1，值2，值3}；</p>
<p>或</p>
<p>变量类型.变量名=值</p>
<p>例：</p>
<p>student stu1={“张三”,18,60}；</p>
<p>或</p>
<p>student stu1；</p>
<p>stu1.name=”张三”;</p>
<p>stu1.age=18;</p>
<p>stu1.score=60;</p>
<ol start="3">
<li>主函数使用</li>
</ol>
<p>变量类型 变量名</p>
<p>例：student stu1；</p>
<p>读取：cout &lt;&lt; stu1.name;</p>
<p>(2)  结构体数组</p>
<p>同普通数组，student stu[n]={“张三”，18，60}；</p>
<p>(3)  结构体指针</p>
<ol>
<li>创建结构体变量</li>
</ol>
<p>student s={“张三”，18，60}；</p>
<ol start="2">
<li>通过指针指向结构体变量</li>
</ol>
<p>student *p =&s;</p>
<ol start="3">
<li>通过指针访问结构体变量中的数据</li>
</ol>
<p>cout &lt;&lt; “姓名：” &lt;&lt; p-&gt;name</p>
<p><strong>十三．引用</strong></p>
<p>(1)引用的基本使用</p>
<p>数据类型 &amp;别名 = 原名</p>
<p>(2)引用的注意事项</p>
<p>1.引用必须初始化</p>
<p>2.引用在初始化后，不可以改变</p>
<p>(3)引用做函数参数</p>
<p>函数传参时,可以利用引用的技术让形参修饰实参，可以简化指针修改实参</p>
<p>(4)引用做函数的返回值</p>
<p>1.不要返回局部变量引用</p>
<p>2.函数调用作为左值</p>
<p>(5)引用的本质</p>
<p>引用的本质在C++内部实现是一个指针常量</p>
<p><strong>十四．函数高级</strong></p>
<p>(1)函数可以设置默认参数，如果传入数据就用传入的数据，没传入就用默认值</p>
<p>(2)如果某个位置已经有了默认参数，那么从这个位置往后，从左到右都必须有默认值</p>
<p>(3)如果函数声明有默认参数，函数实现就不能有默认参数</p>
<p>(4)占位参数：函数名（数据类型）{}</p>
<p>(5)函数重载</p>
<p>1.函数名相同，提高复用性</p>
<p>2.条件：同个作用域，名称相同，参数 类型不同 或 个数不同 或 顺序不同</p>
<p><strong>十五．类和对象</strong></p>
<p>(1)类的定义格式：</p>
<p>class &lt;类名&gt;                    //声明部分</p>
<p>{</p>
<p>  public:</p>
<p>​      &lt;公有数据成员和成员函数的声明或实现&gt;</p>
<p>  protected:</p>
<p>​      &lt;保护数据成员和成员函数的声明或实现&gt;</p>
<p>  private:</p>
<p>​      &lt;私有数据成员和成员函数的声明或实现&gt;</p>
<p>};</p>
<p>&lt;函数类型&gt; &lt;类名&gt;::&lt;成员函数名&gt; (&lt;参数表&gt;)    //实现部分</p>
<p>{</p>
<p>  &lt;函数体&gt;</p>
<p>}</p>
<p>其中，class为关键字；&lt;类名&gt;为标识符；花括号内是类的声明部分，声明该类的成员。类成员包含数据成员和函数成员，数据成员通常是变量或对象的声明语句，而函数成员指函数的定义或声明语句。</p>
<p>public：关键字，说明其后的成员为公有成员。通常将类的成员函数全部或部分定义为公有成员。</p>
<p>private：关键字，可默认，说明其后的成员为私有成员。通常将类的数据成员定义为私有成员，是被隐藏的部分。</p>
<p>protected：关键字，说明其后的成员为保护成员。</p>
<p>关键字public、private和protected称为访问权限控制符或访问权限修饰符，它们在类体中出现的顺序和次数没有限制，用它们来说明类成员的访问权限。</p>
<p>(2) 定义类时需要注意以下几点：</p>
<p>1.在类体内对数据成员定义时，不允许初始化。</p>
<p>2.类中数据成员可以是任意类型的数据：整型、浮点型、字符型、数组、指针和引用等，也可以是对象，但是只能是其他类的对象，而不允许是自身类的对象。</p>
<p>3.当在类体外定义成员函数时，必须在类体内有函数原型语句。</p>
<p>4.一般情况下，在类体内先声明公有成员，后声明私有成员；在声明数据成员时，一般按数据成员的类型大小，由小到大进行声明，这样可以提高时空利用率。</p>
<p>5.通常将类的定义部分存放在一个用户自定义的头文件中，可方便程序使用，如可将上例中点类的定义存放在“point.h”文件中。</p>
<p>(3)访问控制</p>
<p>​    类成员访问权限的控制，体现了类的隐藏和封装性，是通过设置类成员的访问控制属性来实现的。访问控制属性有3种：public（公有）、private（私有）和protected（保护）。</p>
<p>​    公有属性（public）定义了类的外部接口，对类而言，任何外部的访问都要通过外部接口来进行。公有成员即可以在类体内引用，也可以在类外程序中引用，是类与外界的接口，即公有的成员函数或数据成员可以被程序中的任何函数或语句访问（静态成员除外）。</p>
<p>​    私有属性（private）的成员不允许类外部的程序代码对其进行直接访问，只能被本类的成员函数或特殊说明的函数引用，保证了私有成员被隐藏在类中，对外界是不可见的。外部程序代码要访问私有成员，只能通过类内定义的公有成员函数或友元函数，这样就实现了访问控制。</p>
<p>​    保护属性（protected）与私有属性相似，保护成员对于本类相当于私有成员，对于该类的派生类相当于公有成员，即保护的数据成员和成员函数不能被类外程序代码访问，只有类的成员函数和类的派生类才可以访问（类的继承和派生在第六章中会详细讲述）。</p>
<p>(4)成员函数的特性</p>
<p>1．成员函数可以重载</p>
<p>一般成员函数可以重载，构造函数也可以重载，但是析构函数不可以重载。</p>
<p>2．成员函数可以声明为内联函数</p>
<p>成员函数如果定义在类体内，则为内联函数，而定义在类体外则不是内联函数。如果要使定义在类体外的函数也成为内联函数，则需定义时在函数头前加上关键字inline。</p>
<p>3．成员函数的参数可以设置默认值</p>
<p>成员函数的参数可以设置为默认值，使用方法与一般函数的参数默认值相同。</p>
<p>(5)对象的定义方法</p>
<p>​    类是一种类型，不占用内存空间；对象是类的实例，是实体，定义对象时，系统会分配相应的存储空间。任何一个对象都属于某个类，对象包含其所属类的所有成员，因此在定义对象前，必须先定义类。</p>
<p>​    对象中只存放数据成员，成员函数不存放在每个对象中，而是存放在一个可被对象访问的公共区域中。</p>
<p>对象的定义格式如下：</p>
<p>&lt;类名&gt; &lt;对象名表&gt;;</p>
<p>​    其中，&lt;类名&gt;是对象所属的类的名字；&lt;对象名表&gt;可以包含多个对象，对象名之间用逗号间隔。对象名可以是一般对象名，也可以是指向对象的指针名或引用名，还可以是对象数组名。</p>
<p>例如：</p>
<p>Point p1,p2,*pp,&amp;rp=p1,p[10];</p>
<p>​    其中，p1,p2是一般对象名；pp是指向Point类对象的指针；rp是对象p1的引用；p是一维数组，有10个元素，每个元素是类Point的对象。</p>
<p>(6)对象成员的表示方法</p>
<p>一个对象的成员就是该对象所属类的成员：数据成员和成员函数。</p>
<p>1．一般对象的成员表示</p>
<p>&lt;对象名&gt;.&lt;数据成员名&gt;</p>
<p>&lt;对象名&gt;.&lt;成员函数名&gt;(&lt;参数表&gt;)</p>
<p>这里，“.”是成员访问运算符，其功能是表示对象的成员，例如：</p>
<p>Point p1;</p>
<p>则p1.X，p1.Y，p1.SetValue(10,5)等即为对象的成员。</p>
<p>2．指向对象的指针的成员表示</p>
<p>&lt;对象指针名&gt;-&gt;&lt;数据成员名&gt;</p>
<p>&lt;对象名&gt;-&gt;&lt;成员函数名&gt;(&lt;参数表&gt;)</p>
<p>其中，“-&gt;”也是一个表示成员的运算符，用于表示指向对象的指针的成员，例如：</p>
<p>Point p1，*pp;</p>
<p>则pp-&gt;X，pp-&gt;.Y，pp-&gt;SetValue(10,5)，pp-&gt;Move(2,2)等即为成员。</p>
<p>3．对象引用的成员表示</p>
<p>&lt;对象引用名&gt;.&lt;数据成员名&gt;</p>
<p>&lt;对象引用名&gt;.&lt;成员函数名&gt;(&lt;参数表&gt;)</p>
<p>例如：</p>
<p>Point p1,&amp;rp=p1;</p>
<p>则rp.X，rp.Y，rp.SetValue (10,5)等也是成员。</p>
<p>4．对象数组元素的成员表示</p>
<p>&lt;数组名&gt;[&lt;下标&gt;].&lt;数据成员名&gt;</p>
<p>&lt;数组名&gt;[&lt;下标&gt;].&lt;成员函数名&gt;(&lt;参数表&gt;)</p>
<p>(7)构造函数</p>
<p>1.构造函数的名字与类名相同。</p>
<p>2.构造函数没有返回值，不允许定义构造函数的返回值类型，包括void类型。</p>
<p>3.构造函数可以有一个或多个参数，也可以无参数，分别称为有参构造函数和默认构造函数。</p>
<p>4.构造函数可以重载，重载构造函数由其参数个数、参数类型来区分。</p>
<p>5.程序中一般不直接调用构造函数，而是由系统在创建对象时自动调用执行。</p>
<p>默认构造函数有两种：一种是由用户定义，另一种是由系统自动提供。如果用户在一个类体中没有定义任何构造函数，系统会自动创建一个默认的构造函数，其函数体为空，用来对创建的对象进行初始化，使对象中的不同类型的数据成员具有默认值或无意义值，其格式如下：</p>
<p>&lt;类名&gt;::&lt;默认构造函数名&gt;()</p>
<p>{</p>
<p>}</p>
<p>(8)有参构造函数</p>
<p>构造函数可以带有一个或多个参数，创建对象时，如果被创建的对象带有实参，系统会根据实参的个数调用相应的有参构造函数对对象进行初始化。</p>
<p>在定义构造函数时，也可以为函数参数设定默认值。</p>
<p>注意：</p>
<p>若类中已定义有参构造函数，则在需要使用无参构造函数时，必须由用户自己定义无参构造函数，系统默认的无参构造函数已失去作用。</p>
<p>(9)拷贝构造函数</p>
<p>拷贝构造函数具有一般构造函数的功能，其作用是使用已知对象给所创建的对象进行初始化。拷贝构造函数只有一个参数，并且是对某一个对象的引用。其定义格式如下：</p>
<p>&lt;构造函数名&gt;(&lt;类名&gt;&amp;&lt;对象引用名&gt;)</p>
<p>{</p>
<p>​    &lt;函数体&gt;</p>
<p>}</p>
<p>(10)析构函数</p>
<p>析构函数也是一种特殊的成员函数，其功能是用来释放所创建的对象。一个对象在其生存周期将要结束时由系统自动调用析构函数将其从内存中清除，即释放由构造函数分配的内存。</p>
<p>1.析构函数名同类名，为了与构造函数区别，在析构函数名前加“~”符号。</p>
<p>2.析构函数定义时不能给出类型，也无返回值，并且无参数。</p>
<p>3.析构函数不能被重载，一个类中只能定义一个析构函数。</p>
<p>4.析构函数通常被系统自动调用，用户不能调用。</p>
<p>5.如果一个类中没有定义析构函数，则系统提供一个默认析构函数，其格式如下：</p>
<p>&lt;类名&gt;::&lt;默认析构函数名&gt;</p>
<p>{}</p>
<p>默认析构函数的函数体为空。</p>
<p>析构函数在下面两种情况下使用：</p>
<p>1.如果在函数体内定义一个对象，则当函数结束时，系统自动调用析构函数释放该对象；</p>
<p>2.如果一个对象是使用new运算符动态创建的，则在使用delete运算符释放时，会自动调用析构函数。</p>
<p>(11)静态成员</p>
<p>静态成员的提出是为了解决数据共享的问题。为了共享某个数据，可以将该数据声明为全局变量，但这样会削弱数据的封装性，因此用静态成员来实现，既实现了数据共享，又不会影响数据的封装性。静态成员用static来修饰，不管有多少个属于类的对象，其静态成员在内存中只有一个拷贝，为类中所有对象共享。</p>
<p>静态成员有两种：静态数据成员和静态成员函数。</p>
<p>静态数据成员是该类所有对象共有的数据成员，可以实现同类对象之间的信息交换，类中所有对象都可以引用静态数据成员，它的值对每个对象都是一样的。使用静态数据成员可以节省内存，提高系统的运行效率。</p>
<p>在类中定义静态数据成员的格式为：</p>
<p>class &lt;类名&gt;</p>
<p>{</p>
<p>//…</p>
<p>static &lt;类型说明符&gt; &lt;数据成员名&gt;;</p>
<p>//…</p>
<p>};</p>
<p>如：</p>
<p>class A</p>
<p>{</p>
<p>​    public:</p>
<p>​       A(int i){a=i;}</p>
<p>​       //…</p>
<p>​    private:</p>
<p>​       int a;</p>
<p>​       static int s;</p>
<p>};</p>
<p>int A::s=0;</p>
<p>在该程序段中，类A定义了一个静态数据成员s，并在类体外对其进行了初始化。</p>
<p>对静态数据成员初始化必须在类外进行，其格式如下：</p>
<p>&lt;数据类型&gt; &lt;类名&gt;::&lt;数据成员&gt;=&lt;初值&gt;;</p>
<p>静态数据成员不属于某个对象，在给对象分配存储空间时不包括静态数据成员所占的空间。静态数据成员独立于所有对象，占据的存储空间是系统为其开辟的一个单独的空间，该空间与类的对象无关，只要定义了静态数据成员，即使没有定义对象，静态数据成员的空间也已被分配，可以通过对象引用，也可以通过类来引用，引用形式如下：</p>
<p>&lt;类名&gt;::&lt;静态数据成员&gt;</p>
<p>当一个成员函数被声明为static时，即成为静态成员函数，声明格式如下：</p>
<p>static &lt;类型&gt; &lt;成员函数名&gt;(&lt;参数表&gt;);</p>
<p>静态成员函数的实现可以在类体内，也可以在类体外。静态成员函数是类中所有对象所共享的成员函数，而不只属于某个对象。对其引用的方法有两种：</p>
<p>&lt;类名&gt;::&lt;静态成员函数名&gt;(&lt;参数表&gt;)</p>
<p>或</p>
<p>&lt;对象名&gt;.&lt;静态成员函数名&gt;(&lt;参数表&gt;)</p>
<p>正由于静态成员函数不属于某个特定的对象，因此不能像一般的成员函数那样随意地访问对象中的非静态数据成员，只能引用类中声明的静态数据成员。如果要引用非静态数据成员，可通过对象来引用。</p>
<p>(12)this指针</p>
<p>​    this指针是一个隐含于每一个类的成员函数中的特殊指针，它用于指向正在被成员函数操作的对象。this指针是系统创建的，是类的指针类型，存储该类的某个对象的地址。</p>
<p>​    this指针明确指出了成员函数当前所操作的对象，当通过一个对象调用其成员函数时，系统先将该对象的地址赋给this指针，然后调用成员函数，成员函数执行时就隐含使用了this指针。可以使用*this来表示或调用该成员函数的对象。</p>
<p>(13)友元函数</p>
<p>​    在一个类体内声明的友元函数不是该类的成员函数，只是独立于该类的一般函数，但是它具有这个类成员函数所具有的访问该类所有成员的功能。其声明格式如下：</p>
<p>​    friend &lt;类型&gt; &lt;函数名&gt;(&lt;参数表&gt;);</p>
<p>​    友元函数破坏了类的封装性，使用时应特别慎重。</p>
<p>​    友元函数可在类体内任何位置声明，其函数定义一般放在类体外。</p>
<p>(14)友元类</p>
<p>友元不仅可以是函数，还可以是一个类，即一个类可以作为另一个类的友元，该类即为友元类。当一个类是另一个类的友元类时，该类中所有的成员函数都是这个类的友元函数。友元类的声明格式如下：</p>
<p>​    friend class &lt;类名&gt;;</p>
<p><strong>十六．继承</strong></p>
<p>(1) 继承的概念</p>
<p>​    继承是由一个已有类创建一个新类的过程。已有类称为基类或父类，新类称为派生类或子类。派生类从基类继承基类的成员，并根据需要添加新的成员，或对原有的成员进行改造（改写），以适应新类的需求。</p>
<p>​    派生类也可以作为其他类的基类，这个过程可以一直进行下去，从一个基类派生出来的多层类就形成了类的层次结构。</p>
<p>​    现实世界中的许多事物之间不是相互孤立的，它们往往具有共同的特征，也存在内在的差别。人们可以采用层次结构来描述这些实体之间的相似之处和不同之处。例如，动物学根据自然界动物的形态、身体内部构造、胚胎发育的特点、生理习性、生活的地理环境等特征，将特征相同或相似的动物归为同一类。根据身体中是否有脊椎可将动物分为两大门类：有脊椎动物和无脊椎动物，有脊椎动物又可以根据会不会飞、有没有乳腺、有没有鳍等分为哺乳类、鸟类、爬行类、两栖类和鱼类等。</p>
<p>(2)定义格式</p>
<p>class &lt;派生类名&gt;：&lt;继承方式&gt; &lt;基类名&gt;</p>
<p>{</p>
<p>​    &lt;派生类新增成员说明&gt;</p>
<p>}；</p>
<p>其中，&lt;派生类名&gt;是指通过继承派生出来的新类的名字，&lt;基类名&gt;是指这个派生类的基类，必须是已经声明过的类，否则会出现编译错误；&lt;继承方式&gt;由关键字public、private和protected指明。 </p>
<p>继承方式有3种：公有继承，由关键字public表示；私有继承，由关键字private表示；保护继承，由关键字protected表示。如果省略，将默认为private，即私有继承。</p>
<p>不同继承方式下成员的访问属性</p>
<table>
<thead>
<tr>
<th>继承方式</th>
<th>在基类中成员的访问属性</th>
<th>继承到派生类中的访问属性</th>
</tr>
</thead>
<tbody><tr>
<td>公有派生</td>
<td>公有的（public）</td>
<td>公有的（public）</td>
</tr>
<tr>
<td>保护的（protected）</td>
<td>保护的（protected）</td>
<td></td>
</tr>
<tr>
<td>私有的（private）</td>
<td>不可见的</td>
<td></td>
</tr>
<tr>
<td>保护派生</td>
<td>公有的（public）</td>
<td>保护的（protected）</td>
</tr>
<tr>
<td>保护的（protected）</td>
<td>保护的（protected）</td>
<td></td>
</tr>
<tr>
<td>私有的（private）</td>
<td>不可见的</td>
<td></td>
</tr>
<tr>
<td>私有派生</td>
<td>公有的（public）</td>
<td>私有的（private）</td>
</tr>
<tr>
<td>保护的（protected）</td>
<td>私有的（private）</td>
<td></td>
</tr>
<tr>
<td>私有的（private）</td>
<td>不可见的</td>
<td></td>
</tr>
</tbody></table>
<p><strong>十七．多态</strong></p>
<p>(1)虚函数</p>
<p>​    虚函数是包含多态的基础，包含多态与继承密不可分。在第6章中介绍过派生类对象的结构，而派生类对象除了包含从基类继承来的成员外，还包含派生类中新添加的成员，同时还可以改写基类的成员。</p>
<p>​    将成员函数声明为虚函数，只要在函数声明时在函数返回类型前加上关键字virtual即可。说明虚函数的格式如下：</p>
<p>virtual &lt;类型&gt; &lt;函数名&gt;(&lt;参数表&gt;)；</p>
<p>虚函数的使用要注意以下几个问题：</p>
<p>1.基类中的虚函数与派生类中重写的同名函数不但要求名字相同，而且返回值和参数（个数和对应参数的类型）也要相同。否则，编译系统会看做普通的函数重载，即使加上virtual关键字，也不会进行动态绑定。有一种情况例外，就是如果基类中的虚函数返回一个基类的指针或引用，派生类中的虚函数返回一个派生类的指针或引用，C++仍可以视其为虚函数进行动态绑定。</p>
<p>2.基类的虚函数在派生类中仍然是虚函数，并且可以通过派生一直将这个虚函数继承下去，不需要加关键字virtual。</p>
<p>3.虚函数的声明只能出现在类定义时的函数声明中。</p>
<p>4.虚函数必须是类的成员函数，不能是友元函数，因为虚函数仅适用于有继承关系的类对象；不能是静态成员函数，如果基类定义了静态成员，则整个类继承层次中只能有一个这样的成员；不能是内联函数，因为内联函数的代码替换是在编译时完成的。</p>
<p>5.只能通过指针或引用来操作虚函数实现多态，如果是通过对象名访问虚函数，则绑定仍然是在编译时完成，不能实现运行时多态。</p>
<p>设计派生类时，如果不是为了实现多态，最好避免与基类使用相同的成员名，否则会应用同名覆盖的原则。</p>
<p>(2)纯虚函数</p>
<p>在设计基类时，经常遇到基类是一个比较抽象的概念，其成员函数往往不能被全部实现的情况。例如，在图形类中，由于尚不知具体的图形，所以计算面积的成员函数难以实现。为了能够多态地使用该函数，在基类中还需要定义该成员函数，这时可以把它定义为纯虚函数。纯虚函数不需定义函数体，其值为0。纯虚函数的定义形式为：</p>
<p>virtual &lt;类型&gt; &lt;函数名&gt;（&lt;参数表&gt;）=0；</p>
<p>纯虚函数是一种特殊的虚函数，函数体由“=0”来代替。它与空函数不同，空函数有函数体，函数体为空，由一对花括号括起来，含有空函数的类可以创建对象；而纯虚函数没有函数体，“=0”本质上是将指向函数体的指针定义为NULL。含有纯虚函数的类不能创建对象，纯虚函数是为派生类保留一个位置，为所有派生类提供一个公共接口。派生类中必须对纯虚函数进行重写，才能创建对象。</p>
<p><strong>十八．C++文件操作</strong></p>
<p>(1)必须包含头文件<fstream></fstream></p>
<p>(2)操作文件三大类</p>
<p>1.ofstream：写操作</p>
<p>2.ifstream：读操作</p>
<p>3.fstream：读写操作</p>
<p>(3)写文件：</p>
<p>1.包含头文件</p>
<p>#include<fstream></fstream></p>
<p>2.创建流对象</p>
<p>ofstream ofs;</p>
<p>3.打开文件</p>
<p>ifs.open(“文件路径”,打开方式);</p>
<p>4.写数据</p>
<p>ofs &lt;&lt;”写入的数据”;</p>
<p>5.关闭文件</p>
<p>ofs.close();</p>
<p>(4)读文件</p>
<p>1.包含头文件</p>
<p>#include<fstream></fstream></p>
<p>2.创建流对象</p>
<p>ifstream ifs;</p>
<p>3.打开文件并判断文件是否成功</p>
<p>ifs.open(“文件路径”,打开方式);</p>
<p>4.读数据</p>
<p>ifs &gt;&gt;”写入的数据”;</p>
<p>5.关闭文件</p>
<p>ifs.close();</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">SBC</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/01/17/C++%E5%91%A8%E6%8A%A5/">http://example.com/2021/01/17/C++%E5%91%A8%E6%8A%A5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">SBCstudio</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2021/01/27/Linux%E5%91%A8%E6%8A%A5/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux周报</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/SBC.jpg'" alt="avatar"/><div class="author-info__name">SBC</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://space.bilibili.com/392589808"><i class="/img/bi.png"></i><span>关注我</span></a></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/01/27/Linux%E5%91%A8%E6%8A%A5/" title="Linux周报"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux周报"/></a><div class="content"><a class="title" href="/2021/01/27/Linux%E5%91%A8%E6%8A%A5/" title="Linux周报">Linux周报</a><time datetime="2021-01-27T11:45:47.000Z" title="发表于 2021-01-27 19:45:47">2021-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/01/17/C++%E5%91%A8%E6%8A%A5/" title="C++周报"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++周报"/></a><div class="content"><a class="title" href="/2021/01/17/C++%E5%91%A8%E6%8A%A5/" title="C++周报">C++周报</a><time datetime="2021-01-17T11:57:15.000Z" title="发表于 2021-01-17 19:57:15">2021-01-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By SBC</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>